------------------------------------------------------------------
REMOVED SYNTAX FROM RABBIT
------------------------------------------------------------------
* Equational theory
  * `function`
  * `equation`
* structure creation via `new x = I(e_1, ..., e_n)` and `get`
* `delete e`
* system instantiation
* filesystems and paths
* requires, lemma


------------------------------------------------------------------


Identifier id, id', id''' ::= ID                                                        (An [a-zA-Z]* string)
        
alpha ::= Sym | Enc | Dec | Sig | Chk                                       (Key kind)
        
Type t :: =             
  l                                                                           (security level)
  | t * t'                                                                    (product)
  | channel[t, t']                                                            (channel with read and write types t, t' respectively)
  | key[t, l, alpha]                                                          (key used on data of type t with security level l and key kind alpha. Only parties with correct secrecy level and integrity level can access the key)
  | process[t, l]                                                             (process with input parameter of type t and security level l)
  | func[t*, t]                                                                  (function with 0 or more input types t and one return type t (t=Unit if f only does side effects))
        
Raw term r ::=          
x                                                                           (variable, a binder for any raw term r)
| n                                                                         (name n. A name n can have any type and be used as such)
| (u, v)                                                                    (pair)
| id(r*)                                                                    (function application or syscall application)
                                                                            (pk, vk, encryption, decryption, signing, hashing can all be implemented with functions)
| pack(x : t, p)                                                            (x is variable, t is type, p is process term)
                                                                            (not sure if this can be implemented with a function/syscall. The type t really needs to be explicitly given here)
        
Type-annotated term u, v, k ::=  r : t                                      (raw term r which has type t)
        
Fact A ::=          
r = r'                                                                      (equality checking between terms)
| FACT                                                                      (any valid TAMARIN fact)
        
Process term p, q, o ::=            
0                                                                               (nil process)
| r                                                                             return raw term r
| var x : t = r in p                                                            (local variable declaration)
                                                                                (r ::= f(r_1, ..., r_n) | s(r_1, ..., r_n)) //function or syscall calling is included in raw term
| x := r                                                                        (mutation)
| p ; q                                                                         (sequential composition)
| (p | q)                                                                       (parallel composition)
| !p                                                                            (replication)
| exec(u, v)                                                                    (execute mobile process u with value v)
| new n : t in p                                                                (name restriction when I is not given)
| case ([A*] -> p)+ end                                                         (case statement. If any fact A_i holds, it consumes the fact A_i (removes it from the fact environment) and p is run)
                                                                                (if multiple facts are true, one is chosen nondeterministically)
| event [A*]                                                                    (tag current point of computation with event facts A*)
| put [A*]                                                                      (put facts A* into the fact environment)
| repeat ([A*] -> p)+ until ([A'] -> p)+                                        (if either lists of facts A* are true, consume them and do corresponding action p)


syscall_decl ::= `syscall` id((id' : t)*) { p }                                 (syscall declaration)

syscall_id = . | id*                                                            (`.` is any system call)
allow_rule ::= `allow` t1 t2 [syscall_id]                                       (processes of type t1 are allowed to access channels of type t2 via system call id)
                                                                                (Honestly, I think with this syntax, one can also define the security lattice of a system)

passive_attack ::= `passive attack` id(id'*) { p }                              (passive attacks add arbitrary computations p whenever called)
active_attack ::= `attack` id `on` id'(id'''*) { p }                            (active attacks modify the result of system calls)
attack_decl ::= passive_attack* `\n` active_attack*

allow_passive_attack ::= `allow` t [passive_attack*]                            (allow rule for passive attack)
allow_active_attack ::= `allow attack` t [active_attack*]                       (allow rule for active attack)
allow_attack_decls ::=  allow_passive_attack* `\n` allow_active_attack* 

global_const = `const fresh` id | `const` id = r                                  (fresh nonce declaration or binding an expression r to an id globally)
fun ::= `function` id((id' : t)*): t' { p }                                       (function declaration inside of a process. Backticks represent the fact that keyword "function" should be written literally
                                                                                   Furthermore, enforce that a return type t' is given.)
memory_decl ::= `var` id : t = r \n                                               (memory declaration. top-level variable "id" is available throughout the process and is initialized with raw term "r")
proc_decl ::= `process` id((id' : t)*) memory_decl* fun* `main()` { p }           (process declaration. id is process identifier, filesys is filesys declaration, p is process term)


program ::= syscall_decl* (`type` id : t)* allow_rule* attack_decl* allow_attack_decls global_const* proc_decl* system_decl


