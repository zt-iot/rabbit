------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------
REMOVED SYNTAX FROM RABBIT
------------------------------------------------------------------
* Equational theory
  * `function`
  * `equation`
* structure creation via `new x = I(e_1, ..., e_n)` and `get`
* `delete e`
* system instantiation
* filesystems and paths
* requires, lemma
* attack (passive and active)
* allow proc_ty ch_ty [o] (decides which processes are allowed to access which channels) 
* allow attack (...)
------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------
------------------------------------------------------------------

Identifier id, id', id''' ::= ID                                                        (An [a-zA-Z]* string)
        
KeyKind alpha ::= Sym | Enc | Dec | Sig | Chk                                       (Key kind)
        
Type t :: =             
  l                                                                           (security level)
  | t * t'                                                                    (product)
  | channel[l, t, t']                                                         (channel with security level l, read and write types t, t' respectively)
  | key[l, alpha, t]                                                          (key used on data of type t with security level l and key kind alpha. Only parties with correct secrecy level and integrity level can access the key)
  | process[l, t]                                                             (process with input parameter of type t and security level l)
  | func[l, t*, t]                                                            (function with 0 or more input types t and one return type t (t=Unit if f only does side effects), 
                                                                                and security level l of the funcion code)
        
RawTerm r ::=          
x                                                                           (variable, a binder for any raw term r)
| n                                                                         (name n. A name n can have any type and be used as such)
| (u, v)                                                                    (pair)
| id(r*)                                                                    (function application or syscall application)
                                                                            (pk, vk, encryption, decryption, signing, hashing can all be implemented with functions)
| pack(x : t, p)                                                            (x is variable, t is type, p is process term)
                                                                            (not sure if this can be implemented with a function/syscall. The type t really needs to be explicitly given here)
        
Type-annotatedTerm u, v, k ::=  r : t                                      (raw term r which has type t)
        
Fact A ::=          
r = r'                                                                      (equality checking between terms)
        
ProcessTerm p, q, o ::=            
0                                                                               (nil process)
| r                                                                             return raw term r
| var x : t = r in p                                                            (local variable declaration)
                                                                                (r ::= f(r_1, ..., r_n) | s(r_1, ..., r_n)) //function or syscall calling is included in raw term
| x := r                                                                        (mutation)
| p ; q                                                                         (sequential composition)
| (p | q)                                                                       (parallel composition)
| !p                                                                            (replication)
| exec(u, v)                                                                    (execute mobile process u with value v)
| new x in p                                                                    (name restriction when I is not given)
| case ([A*] -> p)+ end                                                         (case statement. If any fact A_i holds, it consumes the fact A_i (removes it from the fact environment) and p is run)
                                                                                (if multiple facts are true, one is chosen nondeterministically)
| repeat ([A*] -> p)+ until ([A'] -> p)+                                        (if either lists of facts A* are true, consume them and do corresponding action p)


SyscallDecl ::= `syscall` id((id' : t)*) { p }                                 (syscall declaration)

TypeDecl ::= `type id : t`                                                     (type declaration)


SecrLevel ::= `public` | id`.s`                                                 (Secrecy level declaration)
                                                                                ("id" should be a valid identifier referring to a process)
IntegLevel ::= `untrusted` | id`.i`                                             (Integrity level declaration)
                                                                                ("id" should be a valid identifier referring to a process)

SecLatticeRule ::= <SecrLevel> `<` <SecrLevel> | <IntegLevel> `<` <IntegLevel>

GlobalConst = `const fresh` id | `const` id = r                                       (fresh nonce declaration or binding an expression r to an id globally)
Fun fun ::= `function` id((id' : t)*): t' { p }                                       (function declaration inside of a process. Backticks represent the fact that keyword "function" should be written literally
                                                                                      (Furthermore, enforce that a return type t' is given.)


MemoryDecl ::= `var` id : t = r \n                                               (memory declaration. top-level variable "id" is available throughout the process and is initialized with raw term "r")
ProcDecl ::= `process` id((id' : t)*) <MemoryDecl>* fun* `main()` { p }           (process declaration. id is process identifier, filesys is filesys declaration, p is process term)

RootProcDecl ::= `process root`((id : t)*) <MemoryDecl> fun* `main()` { p }      (There should be a single root process declaration)
                                                                                  (The other processes are then "mentioned" by the root process. We can think of these "mentions" as simple macro definitions)


Program ::= <SyscallDecl>* <TypeDecl>* <SecLatticeRule>* <GlobalConst>* <ProcDecl>* <RootProcDecl>
