(* https://www-kb.is.s.u-tokyo.ac.jp/~koba/spica2/example/nonce-handshake.txt 

/* simple nonce handshake protocols */

(newSym key)
( *(ch?n.   /*** Alice ***/
     (new msg)
      begin msg.
      ch!{(msg,n)}key
   )
 |
 *(new non)  /*** Bob ***/
    (ch!non
     |
     ch?ctext.  /* Jun: I am afraid non could be read as ctext here */
     decrypt ctext is {x}key in
     split x is (m,non2) in
     check non is non2 in
     end m)
)
*)

function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y

function enc:2
function dec:2
equation dec(enc(x, y), y) = x


(** asynchronous channels *)
syscall send(c, v) {
  put [c::store(v)]
}

syscall recv(c) {
  case 
  | [c::store(v)] →   v 
  end
}

const fresh sym_k (* symmetric key *)

type person_t : process
type chan_t : channel

process alice(ch : chan_t, ch2 : chan_t) : person_t 
{
    main {
        repeat
        | [] →
	    var n = recv(ch) in		        (* receive nonce [n] *)
	    new msg in			        (* a new message [msg] *)
	    event [::Sent(msg, n)];	        (* log (msg, n) *)
	    _ := send(ch2, enc((msg, n), sym_k)) (* send encrypted [(msg, n)] *)
        until				        
        | [::False()] →  skip		        (* never terminate *)
        end
    }
}

process bob(ch : chan_t, ch2 : chan_t) : person_t 
{
    main {
        repeat
        | [] →
	    new n in                     (* new nonce [n] *)
	    _ := send(ch, n);            (* send the nonce *)
	    var dat = recv(ch2) in          (* receive an encrypted data *)
	    var pair = dec(dat, sym_k) in  (* decrypt *)
	    var msg = fst(pair) in          (* message *)
	    var m = snd(pair) in            (* nonce *)
	    case
	    | [n = m] ->                 (* check the nonces are equal *)
	         event [::Valid(msg, n)]  (* successful handshake *)
            | [n != m] ->
	         event [::Invalid()]       (* something went wrong *)
            end
        until
        | [::False()] →  skip (* never terminate *)
        end
    }
}

allow person_t chan_t [send, recv]

channel chan : chan_t
channel chan2 : chan_t

system
  alice(chan, chan2) | bob(chan, chan2)
requires
[
  lemma Valid: (* verified *)
    reachable ::Valid(msg, n) ;

  lemma Invalid: (* falsified *)
    reachable ::Invalid() ;

  lemma Correspondence : (* verified *)
    corresponds ::Valid(msg, n) ~> ::Sent(msg, n)
]
