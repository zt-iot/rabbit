
(* Load buil-in Rabbit functions *)
load "builtin_functions.rab"


(* predefined types *)

type mon : channel[l: ree, r : ree, w : ree]

type ta_up : channel[tee, (tee, tee), (tee, tee)]
type ta_down := C[tee, ree, ree]

type ks : key[tee, Sym, tee]f
type k_root : key[root, p_tee, (ta_up, ta_down)]
type p_ta : process[tee, (ta_up, ta_down)]
type p_tee : process[(Public, root.I), (mon, p_ta)]


process REE() : unit {
  pack(mon : mon -> var y : ree := recv(mon) in 0)
}

process TA() : p_ta {
  pack(chnls : (ta_up, ta_down) -> {
      var c : ta_up = fst(chnls) in
      var c' : ta_down = snd(chnls) in 
      var x : (tee, tee) = recv(c);
      var y : ree = h(x) in
      _ := send(c', y)
    }
  ) 
}

process SE(i2c : U, k : tee, C : U, H : U) : unit {
  new ns : se in

  var m : U = recv(i2c) in
  new m' : U in 
  var ks : ks = hash(k, m, m') in
  var cr' : U = hash(ks, C, m, m') in
  _ := send(i2c, (m', cr'));
  var cr : U = recv(i2c) in
  var cr' : U = hash(ks, H, m, m') in


  case 
  | [cr = cr'] -> {
    var ns' : tee = hash(ns) in
    _ := send(i2c, enc_sym(ns', ks))
  }
  | [cr <> cr'] -> {
    0
  }
}

process TEE(i2c : U, k : tee, C : U, H : U) : p_tee {
  pack(param : (mon, p_ta) -> {
      var mon : mon = fst(param) in 
      var ta : p_ta = snd(param) in
      new nt : tee in 
      new m : U in
      _ := send(i2c, m);
      var pair : (U, U) = recv(i2c) in
      var m' : U = fst(pair) in 
      var cr' U = snd(pair) in 
      var ks : ks = hash(k, m, m') in
      var cr : U = hash(ks, C, m, m') in
      case 
      | [cr = cr'] -> {
        var cr : U = hash(ks, H, m, m') in
        _ := send(i2c, cr);
        var msg : U = recv(i2c) in 
        var ns' = dec_sym(msg, ks) in 
        (new c : ta_up in 
        new c' : ta_down in 0) | exec(ta, (c, c'))
        _ := send(c, (nt, ns'));
        var y : ree = recv(c') in 
        _ := send(mon, y');
      }
      | [cr <> cr'] -> {
        0
      }
    }
  )
}

process DEV(i2c : U, k : tee, C : U, H : U, w : U, root : k_root) {
  var TEE_s : U = recv(w) in
  new mon : mon in

  (* REE and TEE are executed in parallel. `mon` is the communication channel between them *)

  exec(REE, mon) | case TEE_s of verify(TEE : p_tee, vk(root)) ->
                      exec(TEE, (mon, TA)) | SE(i2c, k, C, H) (* Additionally, run the SE in parallel to the TEE *)

  verify(TEE, vk(root))
}


process p(i2c : U, k : tee, C : U, H : U, w : U) {
  (new root : k_root)
  (* I don't think these things are part of the syntax definition of the language? Arbitrary execution of processes TEE, DEV *)
  let TEE_sig = sign(TEE(i2c, k, C, H), root) in
  send(w, (TEE, TEE_sig)) | DEV(i2c, k, C, H, w, root) (* execute DEV and the sending of TEE with its signature in parallel *)
}
