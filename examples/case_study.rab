

load "builtin_functions.rab"


(* predefined types *)

type mon : channel[l: ree, r : ree, w : ree]

type ta_up : channel[tee, (tee, tee), (tee, tee)]
type ta_down := C[tee, ree, ree]

type ks : key[tee, Sym, tee]
type k_root : key[l : root, t : p_tee, (ta_up, ta_down)]
type p_ta : process[tee, (ta_up, ta_down)]
type p_tee : process[(Public, root.I), (mon, p_ta)]



p_ta = process[tee, (ta_up, ta_down)]

process REE() : unit {
  pack(mon : mon -> var y : ree := recv(mon) in 0)
}

process TA() : p_ta {
  pack(chnls : (ta_up, ta_down) -> {
      var c : ta_up = fst(chnls) in
      var c' : ta_down = snd(chnls) in 
      var x : (tee, tee) = recv(c);
      var y : ree = h(x) in
      _ := send(c', y)
    }
  ) 
}

process SE(i2c : U, k : tee, C : U, H : U) : unit {
  new ns : se in

  var m : U = recv(i2c) in
  new m' : U in 
  var ks : ks = hash(k, m, m') in
  var cr' : U = hash(ks, C, m, m') in
  _ := send(i2c, (m', cr'));
  var cr : U = recv(i2c) in
  var cr' : U = hash(ks, H, m, m') in


  case 
  | [cr = cr'] -> {
    var ns' : tee = hash(ns) in
    _ := send(i2c, enc_sym(ns', ks))
  }
  | [cr <> cr'] -> {
    0
  }
}

process TEE(i2c : U, k : tee, C : U, H : U) : p_tee {
  pack((mon : mon, ta : p_ta) -> {
      (* dot separator is not necessary after `new` statement according to syntax definition *)
      (new nt : tee)(new m : U)
      send(i2c, m).
      recv(i2c, m' : U, cr' : U)
      let ks : ks = h(k, m, m').
      let cr : U = h(ks, C, m, m').
      if cr' = cr {
        let cr : U = h(ks, H, m, m') in
        send(i2c, cr).
        recv(i2c, msg : U).
        case msg of 
          (* I suppose running these parallel processes, while c and c' have not been declared in 2nd process, is allowed... *)
          enc_sym(ns' : tee, ks) -> { 
            (* Not sure if this is how the example should be read... *)
            (new c : ta_up)(new c' : ta_down) | exec(ta, (c, c')).
            send(c, (nt, ns')).
            recv(c', y : ree).
            send(mon, y)
          }
      }
    }
  )
}

process DEV(i2c : U, k : tee, C : U, H : U, w : U, root : k_root) {
  var TEE_s : U = recv(w) in
  (new mon : mon) in

  (* REE and TEE are executed in parallel. `mon` is the communication channel between them *)
  exec(REE, mon) | case TEE_s of verify(TEE : p_tee, vk(root)) ->
                      exec(TEE, (mon, TA)) | SE(i2c, k, C, H) (* Additionally, run the SE in parallel to the TEE *)
}


process p(i2c : U, k : tee, C : U, H : U, w : U) {
  (new root : k_root)
  (* I don't think these things are part of the syntax definition of the language? Arbitrary execution of processes TEE, DEV *)
  let TEE_s = sign(TEE(i2c, k, C, H), root) in (* sign code of TEE with signing key root *)
  send(w, (TEE, TEE_s)) | DEV(i2c, k, C, H, w, root) (* execute DEV and the sending of TEE_s in parallel *)
}
