(* simple types *)
data signature

(* security types *)
type pub_sig : signature
type secret_server_sig : signature

(* channel types *)
type udp_t : channel[signature] (* attacker can eavesdrop/tamper this channel *)

(* process types *)
type server_t 	  : process
type client_t 	  : process

(* access control TAMARIN translation *)
allow server_t udp_t [send]
allow client_t udp_t [recv]

(* access control security lattice *)
allow server_t pub_sig 
allow server_t secret_server_sig (* S(secret_server_sig) = `server` because only process `server` has access to it *)

allow client_t pub_sig (* S(pub_sig) = Public because all processes have access to it *)

process server(ch_net : udp_t) : server_t {
    main {
        new sig_public : pub_sig in 
        new sig_private : secret_server_sig in 

        _ := send(ch_net, sig_public) (* well-typed, we can coerce type pub_sig to U=(Public, Untrusted) because all parties
        have access to pub_sig *)
        _ := send(ch_net, sig_private) (* ill-typed because S(secret_server_sig) != Public  *)
        
    }
}

process bob(ch_net : udp_t) : client_t {
    main {
        var sig_public : pub_sig = recv(ch_net) in (* well-typed *)
        var sig_private : secret_server_sig = recv(ch_net)
    }
}

