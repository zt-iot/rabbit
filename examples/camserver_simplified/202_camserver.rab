(* security primitives *)
function pk:1
function sign:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation verify (sign(d, k), d, pk(k)) = true

(** asynchronous channels *)
syscall send(c, v) {
  put [c::store(v)]
}

syscall recv(c) {
  case 
  | [c::store(v)] →   v 
  end
}

(** synchronous rpc channel *)
syscall connect_rpc (c) {
    new x = chid(c) in 
    put [c::conn()]; 
    x
} 

syscall invoke_rpc (cid, f, arg1) {
  let c = cid.chid in
  put [c::invoke(f, arg1)]; 
  case [c:: Returned(v)] → v end
}

syscall close_rpc (cid){
  let c = cid.chid in
  delete cid.chid;
  put[c::exit()]
}

syscall fopen (p) {
  case [p.x] ->
    new y = Fd(x) in 
    put [p.x]; y
  end
}

syscall fread (y){
  let x = y.Fd in
  x
}

syscall fclose (y) {
  delete y.Fd
}


(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type udp_t 	  : channel
type rpc_t 	  : channel

(***********)
(** access control *)
allow client_t udp_t [send]
allow server_t udp_t [recv]

allow client_t rpc_t [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t rpc_t [.]
allow client_t rpc_t [.]

allow client_ta_t readonly_t  [fopen, fread, fclose] 
allow server_t readonly_t     [fopen, fread, fclose]  


(***********)
(** attacker model *)

attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

allow attack server_t [tamper_channel] 

passive attack eaves_mem (v) {
  put [::Out(v)]
}


allow client_t [eaves_mem]


(***********)
(** global constants *)
const fresh priv_k
const pub_k = pk(priv_k)
const fresh sym_k
const fresh init_data

(***********)
(** installed channels and filesystems *)
channel udp : udp_t

channel rpc : rpc_t


(***********)
(** process templates *)
process client(ch_net : udp_t, ch_rpc : rpc_t) : client_t 
{  
  main 
  {

    var conn = connect_rpc(ch_rpc) in 

    repeat 
    | [] ->

      new image in
      
      _ := eaves_mem(image);

      var sig = invoke_rpc(conn, "sign_image", image) in
      
      _ := eaves_mem(sig);
      
      event [::ImgSend(image)];
      
      _ := send(ch_net, (sig, image))

    until 
    | [] -> skip
    end ;

    _ := close_rpc(conn) ;

    event [::ClientClose ()]
  }
}

process client_ta(ch_rpc : rpc_t) : client_ta_t 
{

  main 
  {
    repeat
    | [ch_rpc::invoke(fname, image)] →
        case
        | [fname = "sign_image"] →
          var signed = sign(image, priv_k) in
          put[ch_rpc:: Returned(signed)]		
  
        | [fname != "sign_image"] →
          event [InValidName(fname)]
        end 
    until
    | [ch_rpc::exit()] → skip 
    end;

    event [::ClientTAClose ()]
  }
}

process server(ch_net : udp_t) : server_t 
{
  main 
  {
    repeat 
    | [] →
      var p = recv(ch_net) in
      var res = verify(fst(p), snd(p), pub_k) in 
      case 
      | [res = true] →
        event [::ImgRecvValid(snd(p))]

      | [res != true] →  
        event [::ImgRecvInvalid(snd(p))]
      end
    until
    | [::False()] →  skip 
    end 	    
  }
}


(***********)
system 
  client(udp, rpc)
  |	server(udp) 
  |	client_ta(rpc) 
requires  
[
  lemma Reachable : (* verified *)
    reachable ::ClientClose(), ::ClientTAClose(), ::ImgRecvValid(x)
]
