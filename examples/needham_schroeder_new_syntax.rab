(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true


(* load some primitive syscalls, incl. send and recv *)
load "udp_rpc.rab"


syscall fopen (p) {
  case [p.x] ->
    new y = Fd(x) in 
    put [p.x]; y
  end
}

syscall fread (y) {
  let x = y.Fd in
  x
}

syscall fclose (y) {
  delete y.Fd
}


(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process

type udp_t 	  : channel



(***********)
(** access control *)
allow client_t udp_t [send, recv]
allow client_t readonly_t  [fopen, fread, fclose]




(** declare passive and active attacks *)

passive attack eaves_mem (v) {
  put [::Out(v)]
}

attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

attack tamper_file on fopen (p) {
  case [p.x, ::In(w)] -> 
    new y = Fd(w) in 
    put [p.w]; y
  end
}

(***********)
(** attacker model *)
allow client_t [eaves_mem]

allow attack client_t [tamper_channel]
allow attack client_t [tamper_file]


(***********)
(** global constants *)
const fresh nonce_a
const fresh nonce_b
const fresh priv_key_alice
const fresh priv_key_bob


(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel *)


(***********)
(** process templates *)

process alice(ch_net : udp_t) : client_t
{
    file "/secret/pub_bob" : readonly_t = pk(priv_key_bob)

  	main 
  	{
      var pub_key_bob_fd = fopen("/secret/pub_bob") in    
      var pub_key_bob = fread(pub_key_bob_fd) in 
      var c_txt1 = enc((nonce_a, "Alice"), pub_key_bob) in 

      _ := eaves_mem(c_txt1);
      _ := send(ch_net, c_txt1);
      event [::AliceSendNonceA(nonce_a)];

      var c_txt2 = recv(ch_net) in
      var p_txt2 = dec(c_txt2, priv_key_alice) in

      var echo_nonce_a = fst(p_txt2) in 
      var nonce_b = snd(p_txt2) in 

      (* In principle, Alice should only send the final message if nonce_a == echo_nonce_a *)
      case 
      | [::AliceSendNonceA(echo_nonce_a)] →
        var c_txt3 = enc(nonce_b, pub_key_bob) in 

        _ := eaves_mem(c_txt3);
        _ := send(ch_net, c_txt3);
        event [::SecretNonceAlice(echo_nonce_a)] (* declares that `echo_nonce_a` has been established as a shared secret *)
      end;
      
      _ := fclose(pub_key_bob_fd);
      event [::AliceClose()]
  	}
}

process bob(ch_net : udp_t) : client_t
{
  (* Use public key of Alice to verify message *)
  var pub_key_alice = pk(priv_key_alice)

  main 
  {
    event [::BobOpen ()];

    var c_txt1 = recv(ch_net) in 

    (* shadowing *)
    var nonce_a = fst(dec(c_txt1, priv_key_bob)) in 
    event [::BobRecv(nonce_a)];

    var c_txt2 = enc((nonce_a, nonce_b), pk(priv_key_alice)) in 

    _ := eaves_mem(c_txt2);
    _ := send(ch_net, c_txt2); 
    event [::BobSendNonceB(nonce_b)]; 

    var c_txt3 = recv(ch_net) in 
    var echo_nonce_b = dec(c_txt3, priv_key_bob) in 

    (* output SecretNonceBob event if the nonce that Bob receives equals the one he sent *)
    case 
    | [::BobSendNonceB(echo_nonce_b)] →
      event [::SecretNonceBob(echo_nonce_b)] (* declares that `echo_nonce_b` has been established as a shared secret *)
    end;

    event [::BobClose()]
  }
}


system 
    alice(udp)
|   bob(udp)
requires [
    lemma Correspondence1 :
      all-traces "All #j  . BobClose() @ #j ==> BobClose() @ #j" ;
    lemma Reachable : 
      reachable ::BobOpen() ;
    lemma Correspondence3 : 
      exists-trace "Ex #i . BobOpen() @ #i " ;

    lemma SecrecyIsEstablished : 
      exists-trace "Ex na #i nb #j . SecretNonceAlice(na) @ i & SecretNonceBob(nb) @ j" ; 
    
    lemma NonceSecrecyA : 
      all-traces "All na #i . SecretNonceAlice(na) @ i ==> not(Ex #l . K(na) @ l)" ;

    (* it cannot be that na is established as a secret and attacker knows it *)
    lemma NonceSecrecyA_Alternative : 
      all-traces "not(Ex na #i #j . SecretNonceAlice(na) @ i & K(na) @ j)" ;

    lemma NonceSecrecyB : 
      all-traces "All nb #j . SecretNonceBob(nb) @ #j ==> not(Ex #m . K(nb) @ #m)" ;

    (* it cannot be that nb is established as a secret and attacker knows it *)
    lemma NonceSecrecyB_Alternative : 
      all-traces "not(Ex nb #i #j . SecretNonceBob(nb) @ i & K(nb) @ j)"


]