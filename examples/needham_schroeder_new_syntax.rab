(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true

(* load syscalls on channels (send/recv) *)
load "udp_rpc.rab"


syscall fopen (p) {
  case [p.File(x)] ->
    new y = Fd(x) in 
    put [p.File(x)]; y
  end
}

syscall fread (y) {
  let x = y.Fd in
  x
}

syscall fclose (y) {
  delete y.Fd
}

(***********)
(** declare types with their classes *)
type client_t 	  : process

type udp_t 	  : channel





(***********)
(** access control *)
allow client_t udp_t [send, recv]
allow client_t readonly_t  [fopen, fread, fclose]



(***********)
(** attacker model *)

attack tampar_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

attack tamper_file on fopen (p) {
  case [p.File(x), ::In(w)] -> 
    new y = Fd(w) in 
    put [p.File(w)]; y
  end
}


passive attack eaves_mem (v) {
  put [::Out(v)]
}

allow client_t [eaves_mem]

(***********)
(** global constants *)
const fresh nonce_a
const fresh nonce_b
const fresh priv_key_alice
const fresh priv_key_bob


(***********)
(** installed channels and filesystems *)
channel udp : udp_t

process alice(ch_net : udp_t) : client_t {
    
    file "/secret/pub_bob" : readonly_t = pk(priv_key_bob)

    main {
        (* on fopen, attacker can supply filedescriptor with different content than expected,
        modelling the situation that attacker is able to convince Alice to initiate a session with them *)
        var pub_key_bob_fd = fopen("/secret/pub_bob") in
        var pub_key_bob = fread(pub_key_bob_fd) in 
        var c_txt1 = enc((nonce_a, "Alice"), pub_key_bob) in 
        _ := send(ch_net, c_txt1);

        var c_txt2 = recv(ch_net) in 
        (* shadowing *)
        var nonce_b = snd(dec(c_txt2, priv_key_alice)) in 
        var c_txt3 = enc(nonce_b, pub_key_bob) in 
        _ := send(ch_net, c_txt3);

        fclose(pub_key_bob_fd);

    }
}


process bob(ch_net : udp_t) : client_t {
    main {
        var c_txt1 = recv(ch_net) in 

        (* shadowing *)
        var nonce_a = fst(dec(c_txt1, priv_key_bob)) in 
        var c_txt2 = enc((nonce_a, nonce_b), pk(priv_key_alice)) in 
        _ := send(ch_net, c_txt2);


    }
}


system 
    alice(udp)
||  bob(udp)
requires [
    (* Secrecy of the nonce *)
    all-traces "not DummyEvent()"
]

