(* https://www-kb.is.s.u-tokyo.ac.jp/~koba/spica2/example/nonce-handshake.txt 

/* simple nonce handshake protocols */

(newSym key)
( *(ch?n.   /*** Alice ***/
     (new msg)
      begin msg.
      ch!{(msg,n)}key
   )
 |
 *(new non)  /*** Bob ***/
    (ch!non
     |
     ch?ctext.  /* Jun: I am afraid non could be read as ctext here */
     decrypt ctext is {x}key in
     split x is (m,non2) in
     check non is non2 in
     end m)
)
*)

function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y

function enc:2
function dec:2
equation dec(enc(x, y), y) = x


(** asynchronous channels *)
syscall send(c, v) {
  put [c::store(v)]
}

syscall recv(c) {
  case 
  | [c::store(v)] â†’   v 
  end
}

const fresh sym_k (* symmetric key *)

type person_t : process
type chan_t : channel

process bob(ch : chan_t, ch2 : chan_t) : person_t 
{
    main {
        new n in		      (* new nonce [n] *)
        _ := send(ch, n);	      (* send the nonce *)

        var n2 = recv(ch) in		     (* receive nonce [n] *)
        new msg in			     (* a new message [msg] *)
        event [::Sent(msg, n2)];		     (* log (msg, n) *)
        _ := send(ch2, enc((msg, n2), sym_k)); (* send encrypted [(msg, n)] *)

        var dat = recv(ch2) in        (* receive an encrypted data *)
        var pair = dec(dat, sym_k) in (* decrypt *)
        var msg2 = fst(pair) in        (* message *)
        var m = snd(pair) in          (* nonce *)
        case
        | [n = m] ->		      (* check the nonces are equal *)
             event [::Valid(msg2, n)]  (* successful handshake *)
        | [n != m] ->
             event [::Invalid()]      (* something went wrong *)
        end
    }
}

allow person_t chan_t [send, recv]

channel chan : chan_t
channel chan2 : chan_t

system
  bob(chan, chan2)
requires
[
  lemma Valid: (* verified *)
    reachable ::Valid(msg, n) ;

  lemma Invalid: (* falsified *)
    reachable ::Invalid() ;

  lemma Correspondence : (* verified *)
    corresponds ::Valid(msg, n) ~> ::Sent(msg, n)
]
