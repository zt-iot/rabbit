(* security primitives *)
function pk:1
function sign:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation verify (sign(d, k), d, pk(k)) = true



(* load some primitive syscalls, incl. send and recv *)
load "udp_rpc.rab"

(* syscall that returns some fresh globally known message *)
syscall message () return m : [::Fr(m)] -> [] (* name restriction *)


(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process

type udp_t 	  : channel



(***********)
(** access control *)

(* clients can both send and receive messages on udp_t channels *)
allow client_t udp_t [send, recv]

(** clients are allowed to generate fresh messages *)
allow client_t [message]



(***********)
(** attacker model *)

(* declare active attacks *)

(* tamper message *)
attack tamper_ch (channel c) : [c::store(v), In(w)] -> [c::store(w)]


(* declare passive attacks *)

(* Eavesdropping *)
passive attack eaves_mem (v) : [] -> [::Out(v)]


(* Allow tamper_ch attack on udp_t channel *)
allow attack udp_t [tamper_ch]


(* Allow passive attack "eaves_mem" on "client_t" type channels *)
allow client_t [eaves_mem]




(***********)
(** global constants *)
const fresh priv_key_alice

(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel for now *)


(***********)
(** process templates *)

process alice(ch_net : udp_t) : client_t
{
    
  	main 
  	{
      let msg = message();
      let sig = sign(msg, priv_key_alice);


      (* Allow passive eavesdropping attack to happen after sig has been created*)
      eaves_mem((msg, sig));
      
      (* Send msg appended with signature to Bob *)
      let _ = send(ch_net, (msg, sig)) @ MsgSend(msg);

      skip @ AliceClose ();
  	}
}

process bob(ch_net : udp_t) : client_t
{
  (* Use public key of Alice to verify message *)
  let pub_key_alice = pk(priv_key_alice);

  main 
  {
    
    let msg_with_sig = recv(ch_net);

    let res = verify(snd(msg_with_sig), fst(msg_with_sig), pub_key_alice);

    if (res = true) 
    {
        skip @ IntegritySuccess(fst(msg_with_sig));
    }
    else 
    {
        skip @ IntegrityFail(fst(msg_with_sig));
    }

    skip @ BobClose ();
  }
}


system
   alice(udp)
|| bob(udp)
requires  [
  (* System must eventually terminate *)
  lemma Reachability : reachable AliceClose(), BobClose() ; 
  
  (* If msg has integrity, it should have been sent earlier *)
  lemma Correspondence : corresponds IntegritySuccess(msg) ~> MsgSend(msg) 
  ]
