(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, pk(k)) = true

(* load syscalls on channels *)
load "udp_rpc.rab"

(* picture *)
syscall get_picture () {
	wait [::Fr(v)] then 
		return v 
	end
}

(* filesys *)
function h:1

syscall fopen (p) {
	put[open(p)]; 
	return h(p)
}

syscall fread (y){
	wait[y = h(p)] then 
		wait[p.File(x), open(p)] then 
			put[p.File(x), open(p)];
			return x
		end
	end
}

syscall fclose (y) {
	wait[y = h(p)] then 
		wait[open(p)] then 
			skip
		end
	end
}

(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type udp_t 	  : channel
type rpc_t 	  : channel

(***********)
(** access control *)
allow client_t udp_t [send]
allow server_t udp_t [recv]

allow client_t rpc_t [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t rpc_t [accept_rpc]
allow client_ta_t rpc_t [.]

allow client_t [get_picture]

allow client_ta_t readonly_t  [fopen, fread, fclose] 
allow server_t readonly_t     [fopen, fread, fclose]  


(***********)
(** attacker model *)

(*
attack tampar_ch (c) {
	wait [c::store, In(w)] then 
		put [c::store(w)]
	end
}
*)

passive attack eaves_mem (v) {
	put [::Out(v)]
}

(** allow attack udp_t [tampar_ch] *)
allow client_t [eaves_mem]


(***********)
(** global constants *)
const fresh priv_k
const fresh sym_k
const fresh init_data


(***********)
(** installed channels and filesystems *)
channel udp : udp_t

channel rpc : rpc_t

filesys client_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys server_fs = 
  [ 
    {path: "/secret/pub", data: pk(priv_k), type: readonly_t}
  ]

filesys client_ta_fs = 
  [ 
    {path: "/secret/priv", data: enc(priv_k, sym_k), type: readonly_t}
  ]

(***********)
(** process templates *)
process client(ch_net : udp_t, ch_rpc : rpc_t) : client_t 
{  
	let dev_path = "/dev/camera"
	let privkey_path = "/secret/priv"
	let invoke_func = "sign_image"

	main 
  	{

			let conn = connect_rpc(ch_rpc) in 
			
			let image = get_picture() in 

			let sig = invoke_rpc(conn, invoke_func, image, privkey_path) in

			_ := eaves_mem((sig, image));

			_ := send(ch_net, (sig, image)); 

			@ [::ImgSend(image)];
		    	
	  	_ := close_rpc(conn) ;

	  	@ [::ClientClose ()]
  	
  	}
}

process client_ta(ch_rpc : rpc_t) : client_ta_t 
{
	let fek = sym_k

	function sign_image(image, privkey_path) 
	{
    (* 
    let privkey_fd = fopen(privkey_path) in
    
    let privkey = fread(privkey_fd) in
    
    let privkey0 = dec(privkey, fek) in 
    
    let sig = sign(image, privkey0) in
    
    _ := fclose(privkey_fd);

    return sig *)

    let sig = sign(image, dec(enc(priv_k, sym_k), fek)) in
    	return sig

	}
  
	main 
	{
		_ := accept_rpc(ch_rpc);
		repeat
				wait [ch_rpc::invoke(fname, image, priv_path)] then 
					case
					|	wait [fname = "sign_image"] then 
							let signed = sign_image(image, priv_path) in
		  					put[ch_rpc::returned(signed)]		
		  			end
		  		| wait [fname <> "sign_image"] then 
		  				@[InValidName(fname)]
		  			end 
		  		end
		  	end
		until
			wait [ch_rpc::exit()] then skip end
		end;
		@ [::ClientTAClose ()]
  	
	}
}

process server(ch_net : udp_t) : server_t 
{
	let pubkey_path = "/secret/pub"
  
	main 
	{
	    let pubkey_fd = fopen(pubkey_path) in 
	    @ [::A()];
	    let pubkey = fread(pubkey_fd) in 
	    @ [::B()];
	    repeat
	    	let p = recv(ch_net) in
				let res = verify(fst(p), snd(p), pubkey) in 
				case 
				|	wait [res =  true] then 
						@[::ImgRecvValid(snd(p))]
					end
				| wait [res <> true] then 
						@[::ImgRecvInvalid(snd(p))]
					end
				end
			until
				wait [::False()] then skip end
			end 	    
  	}
}


(***********)
system 
	client(udp, rpc) with client_fs
||	server(udp) with server_fs 
||	client_ta(rpc) with client_ta_fs
requires  [
  lemma Reachable1 :
    exists-trace "Ex #j  . A() @ #j" ;
  lemma Reachable2 :
    exists-trace "Ex #j  . B() @ #j" ;
  lemma Reachable3 :
    exists-trace "Ex #j  . AAA() @ #j" ;
  lemma Reachable4 :
    exists-trace "Ex #j  . BBB() @ #j" ;
  lemma Reachable5 :
    exists-trace "Ex x #j  . Took(x) @ #j" ;
  lemma Reachable :
    exists-trace "Ex x #i #j  . ClientClose() @ #j & ImgRecvValid(x) @ #i" ;

  lemma Correspondence :
    all-traces "All x #j  . ImgRecvValid(x) @ #j ==> Ex #i . ImgSend (x) @ i & i < j" 
  ]

