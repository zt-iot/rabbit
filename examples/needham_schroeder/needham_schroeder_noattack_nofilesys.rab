(**
needham_schroeder_noattack_nofilesys: a model of the Needham-Schroeder protocol

Goal of the protocol: 

- To establish both nonce_a and nonce_b as secrets

This program is expected to verify all lemmas, because we have turned off attacks
* )


(* security primitives *)
function pk:1
function enc:2
function sign:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation dec(enc(x, pk(d)), d) = x
equation verify (sign(d, k), d, pk(k)) = true


(* load some primitive syscalls, incl. send and recv *)
load "udp_rpc.rab"


syscall fopen (p) {
  case [p.x] ->
    new y = Fd(x) in 
    put [p.x]; y
  end
}

syscall fread (y) {
  let x = y.Fd in
  x
}

syscall fclose (y) {
  delete y.Fd
}


(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process

type udp_t 	  : channel



(***********)
(** access control *)
allow client_t udp_t [send, recv]
allow client_t readonly_t  [fopen, fread, fclose]




(** declare passive and active attacks *)

passive attack eaves_mem (v) {
  put [::Out(v)]
}

attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

attack tamper_file on fopen (p) {
  case [p.x, ::In(w)] -> 
    new y = Fd(w) in 
    put [p.w]; y
  end
}

(***********)
(** attacker model *)

(* UNCOMMENT FOLLOWING LINE TO TURN ON PASSIVE ATTACKS *)
(* 
allow client_t [eaves_mem]
*)

(* UNCOMMENT FOLLOWING TWO LINES TO TURN ON ACTIVE ATTACKS *)
(* 
allow attack client_t [tamper_channel]
allow attack client_t [tamper_file]
*)

(***********)
(** global constants *)
const fresh nonce_a
const fresh nonce_b
const fresh priv_key_alice
const fresh priv_key_bob


(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel *)


(***********)
(** process templates *)

process alice(ch_net : udp_t) : client_t
{
    (* UNCOMMENT FOLLOWING LINE TO TURN ON FILESYSTEM *)
    (* file "/secret/pub_bob" : readonly_t = pk(priv_key_bob) *)

    var loc_nonce_a = nonce_a
    var pub_key_bob_mem = pk(priv_key_bob)

  	main 
  	{
      (* UNCOMMENT TO TURN ON FILESYSTEM *)
      (*
      var pub_key_bob_fd = fopen("/secret/pub_bob") in (* this is tampered by attacker to point to attacker's public key *)
      var pub_key_bob = fread(pub_key_bob_fd) in 
      *)
      
      (* COMMENT FOLLOWING LINE TO TURN ON FILESYSTEM *)
      var pub_key_bob = pub_key_bob_mem in 

      var c_txt1 = enc((loc_nonce_a, "Alice"), pub_key_bob) in (* pub_key_bob is tampered, therefore, loc_nonce_a is readable by the attacker *)

      _ := eaves_mem(c_txt1);
      _ := send(ch_net, c_txt1);
      put [::AliceSendNonceA(loc_nonce_a)];
      event [::AliceSendNonceATag(loc_nonce_a)];

      var c_txt2 = recv(ch_net) in
      var p_txt2 = dec(c_txt2, priv_key_alice) in

      var echo_loc_nonce_a = fst(p_txt2) in 
      var loc_nonce_b = snd(p_txt2) in 

      (* In principle, Alice should only send the final message if loc_nonce_a == echo_loc_nonce_a *)
      case 
      | [echo_loc_nonce_a = loc_nonce_a] →
        event [::SecretNonceAlice(loc_nonce_a)]; (* declares that `loc_nonce_a` has been established as a shared secret *)

        var c_txt3 = enc(loc_nonce_b, pub_key_bob) in (* pub_key_bob is tampered, therefore, loc_nonce_b is readable by the attacker *)
        _ := eaves_mem(c_txt3);
        _ := send(ch_net, c_txt3);
        event [::AliceSendNonceBTag(loc_nonce_b)]
        
      end;
      
      (* UNCOMMENT FOLLOWING LINE TO TURN ON FILESYSTEM *)
      (* _ := fclose(pub_key_bob_fd); *)

      event [::AliceClose()]
  	}
}

process bob(ch_net : udp_t) : client_t
{
  (* Use public key of Alice to verify message *)
  var loc_nonce_b = nonce_b
  var pub_key_alice = pk(priv_key_alice)

  main 
  {
    event [::BobOpen ()];

    var c_txt1 = recv(ch_net) in 

    (* shadowing *)
    var loc_nonce_a = fst(dec(c_txt1, priv_key_bob)) in 
    var c_txt2 = enc((loc_nonce_a, loc_nonce_b), pub_key_alice) in 

    _ := eaves_mem(c_txt2);
    _ := send(ch_net, c_txt2); 
    put [::BobSendNonceB(loc_nonce_b)]; 
    event [::BobSendNonceBTag(loc_nonce_b)];

    var c_txt3 = recv(ch_net) in 
    var echo_loc_nonce_b = dec(c_txt3, priv_key_bob) in 

    (* output SecretNonceBob event if the nonce that Bob receives equals the one he sent *)
    case 
    | [echo_loc_nonce_b = loc_nonce_b] →
      event [::SecretNonceBob(loc_nonce_b)] (* declares that `echo_loc_nonce_b` has been established as a shared secret *)
    end;

    event [::BobClose()]
  }
}


system 
    alice(udp)
|   bob(udp)
requires [
    lemma tautology :
      all-traces "All #j  . BobClose() @ #j ==> BobClose() @ #j" ;
      
    lemma BobOpenReachable : 
      reachable ::BobOpen() ;
    lemma BobOpenReachable_tmrn : 
      exists-trace "Ex #i . BobOpen() @ #i " ;

    lemma NonceAIsSent : 
      reachable ::AliceSendNonceATag(nonce_a);
    lemma NonceAIsSent_tmrn : 
      exists-trace "Ex na #i . AliceSendNonceATag(na) @ i" ;


    lemma NonceBIsSent : 
      reachable ::BobSendNonceBTag(nonce_b) ;
    lemma NonceBIsSent_tmrn : 
      exists-trace "Ex nb #j . BobSendNonceBTag(nb) @ j" ;

    (* lemma: 3rd message gets sent in some trace *)
    lemma NonceBIsSentByAlice : 
      reachable ::AliceSendNonceBTag(nonce_b) ;
    
    lemma SecrecyCanBeEstablishedA : 
      reachable ::SecretNonceAlice(nonce_a) ;
    lemma SecrecyCanBeEstablishedA_tmrn : 
      exists-trace "Ex na #i  . SecretNonceAlice(na) @ i" ; 

    lemma SecrecyCanBeEstablishedB : 
      reachable ::SecretNonceBob(nonce_b) ;
    lemma SecrecyCanBeEstablishedB_tmrn : 
      exists-trace "Ex nb #j . SecretNonceBob(nb) @ j" ;
    
    lemma NonceSecrecyA : 
      all-traces "All na #i . SecretNonceAlice(na) @ i ==> not(Ex #l . K(na) @ l)" ;

    lemma NonceSecrecyB : 
      all-traces "All nb #i . SecretNonceBob(nb) @ i ==> not(Ex #m . K(nb) @ m)" ;

    (* it cannot be that na is established as a secret and attacker knows it *)
    lemma NonceSecrecyA_tmrn : 
      all-traces "not(Ex na #i #j . SecretNonceAlice(na) @ i & K(na) @ j)" ;

    (* it cannot be that nb is established as a secret and attacker knows it *)
    lemma NonceSecrecyB_tmrn : 
      all-traces "not(Ex nb #i #j . SecretNonceBob(nb) @ i & K(nb) @ j)"


]