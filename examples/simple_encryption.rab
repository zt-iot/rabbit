(* security primitives *)

function enc:2 (* enc(msg, sym_key) *)
function dec:2 (* dec(ciphertext, sym_key) *)

equation dec(enc(x, y), y) = x



(* load some primitive syscalls, incl. send and recv*)
load "udp_rpc.rab"


(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process

type udp_t 	  : channel



(***********)
(** access control *)
allow client_t udp_t [send, recv]



(***********)
(** attacker model *)

(* declare active attacks *)

(* tamper message *)
(* attack tamper_ch (channel c) : [c::store(v), In(w)] -> [c::store(w)] *)




(* declare passive attack *)
passive attack eaves_mem (v) : [] -> [::Out(v)]


(* Allow passive attack "eaves_mem" on "client_t" type channels *)
allow client_t [eaves_mem]




(***********)
(** global constants *)
const fresh sym_key (* Both A and B should have access to this *)
const fresh msg_a (*A sends encrypted version, B decrypts with private key *)
(*There are no public keys for now *)



(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel for now *)


process client1(ch_net : udp_t) : client_t
{
  	main 
  	{
      let ciphertext = enc(msg_a, sym_key);

      (* Send encrypted message to B *)
      send(ch_net, ciphertext);
    	
      skip @ DummyEvent ();
      skip @ Client1Close ();
  	}
}

process client2(ch_net : udp_t) : client_t
{
  main 
  {
    let ciphertext = recv(ch_net);

    (* Decrypt encrypted message with same symmetric key used to encrypt it *)
    let plaintext = dec(ciphertext, sym_key);

    skip @ Client2Close ();

  }
}


system
   client1(udp)
|| client2(udp)
requires  [
	lemma Reachability : reachable Client2Close(), Client1Close() ;
  lemma Correspondence : corresponds Client1Close() ~> DummyEvent() 
  ]

(* There is not much to verify, since Rabbit isn't really designed to handle cryptanalysis attacks *)
