data image
data signature

(* types for defining security lattice *)

type client_img : image (* client_img is supposed to have security level (Public, i) with i < Untrusted *)
type client_ta_sig : signature (* client_ta_sig is supposed to have security level (Public, j) with j <= i < Untrusted *)

(* channel types *)
type udp_t : channel[signature * image] (* attacker can eavesdrop/tamper this channel *)
type img_chnl_t : channel[client_img] (* attacker cannot tamper this channel *)
type sig_chnl_t : channel[client_ta_sig] (* attacker cannot tamper this channel *)

(* process types *)
type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process


(* access control *)
allow client_t client_ta_sig (* client_ta is allowed access to signature generated by client_ta *)
allow client_t client_img (* client_t is allowed to read/write client_img *)
allow client_t udp_t [send]
allow client_t img_chnl_t [send]
allow client_t sig_chnl_t [recv]

allow client_ta_t client_ta_sig (* Client TA is allowed to read/write client_ta_sig *)
allow client_ta_t client_img (* Client TA is allowed to access images generated by client *)
allow client_ta_t img_chnl_t [recv]
allow client_ta_t sig_chnl_t [send]

allow server_t udp_t [recv]
(* server_t can only access types image and signature, which are considered to have security level (Public, Untrusted) *)
(* note that server_t is NOT allowed to access `client_img` and `client_ta_sig` *)








(* alternatively, we can think of the access control as follows: *)

(* 
1. A part which is necessary for TAMARIN translation
allow client_t udp_t [send]
allow client_t img_chnl_t [send]
allow client_t sig_chnl_t [recv]

allow client_ta_t img_chnl_t [recv]
allow client_ta_t sig_chnl_t [send]

allow server_t udp_t [recv]

2. A part which is necessary to define the security levels of types we have defined, e.g. client_img, client_ta_sig, udp_t etc.
allow client_t client_img  // client_t is allowed to read/write client_img 

allow client_ta_t client_img // TA is allowed to access client's secrets
allow client_ta_t client_ta_sig // client is allowed to access resulting signature of client TA 

Implicity, server process is allowed to access `signature` and `image` types because they are declared as simple types.
*)


(* 'a is inferred when arguments are given *)
syscall send(c : channel['a], v : 'a) : unit {
  put [c::store(v)]
}

(* 'a is inferred when arguments are given *)
syscall recv(c : channel['a]) : 'a {
    case 
  | [c::store(v)] â†’   v 
}

process client(ch_net : udp_t, ch_img : img_chnl_t, ch_sig : sig_chnl_t) : client_t {
    main {
        var img : client_img = get_image() in 
        _ := send(ch_img, img); (* well-typed *)

        var sig : client_ta_sig = recv(ch_sig) in (* well-typed *)

        (* If we have client_ta_sig <: signature /\ client_img <: image, then the following send is well-typed: *)
        _ := send(ch_net, (sig, img)) 
    }
}

process client_ta(ch_img : img_chnl_t, ch_sig : sig_chnl_t) : client_ta_t {
    main {
        var img : client_img = recv(ch_img) in (* well-typed *)
        var sig : client_ta_sig = sign(img) in
        _ := send(ch_sig, sig) (* well-typed *)
    }
}


process server(ch_net : udp_t) : server_t {
    main {
        var (sig, img) : signature * image = recv(ch_net)
    }
}
