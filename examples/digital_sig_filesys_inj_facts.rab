(* security primitives *)
function pk:1
function sign:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true:0
function verify:3
equation verify (sign(d, k), d, pk(k)) = true



(* load some primitive syscalls, incl. send and recv *)
load "udp_rpc.rab"

(* syscall that returns some fresh globally known message *)
syscall message () {
  new v in 
  v
}

(* declare syscalls for handling filesystems *)

syscall fopen (p) {
  case [p.File(x)] ->
    new y = Fd(x) in 
    put [p.File(x)]; y
  end
}

syscall fread (y){
  let x = y.Fd in
  x
}

syscall fclose (y) {
  delete y.Fd
}

(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process

type udp_t 	  : channel



(***********)
(** access control *)

(* clients can both send and receive messages on udp_t channels *)
allow client_t udp_t [send, recv]

(** clients are allowed to generate fresh messages *)
allow client_t [message]



(***********)
(** attacker model *)

(* Declare active attacks *)

(* tamper message *)
 
attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

(* Allow tamper_channel attack on client_t type processes *)
allow attack client_t [tamper_channel]

(* Declare passive attacks *)

(* Eavesdropping *)
passive attack eaves_mem (v) {
  put [::Out(v)]
}

(* Allow passive attack "eaves_mem" on "client_t" type processes *)
allow client_t [eaves_mem]



(***********)
(** global constants *)
const fresh priv_key_alice

(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel for now *)


(* Filesystem for Alice, saving the private key of Alice *)

filesys alice_fs = 
  [
    {path: "/keys/priv", data: priv_key_alice, type: readonly_t}
  ]

(* Filesystem for Bob, which saves the public key of Alice *)
filesys bob_fs = 
  [
    {path: "/keys/pub_alice", data: pk(priv_key_alice), type: readonly_t}
  ]




(***********)
(** process templates *)

process alice(ch_net : udp_t) : client_t
{   
    var priv_key_path = "/keys/priv"
  	main 
  	{

      event [::AliceClose()];

      var msg = message() in

      (* Allow passive eavesdropping attack to happen after sig has been created *)
      (* _ := eaves_mem(msg);*)

      var priv_key_fd = fopen(priv_key_path) in
      var priv_key = fread(priv_key_fd) in
      
      
      var sig = sign(msg, priv_key) in
      (* _ := eaves_mem(sig); *)
      _ := fclose(priv_key_fd);
      
      (* Send msg appended with signature to Bob *)
      (* event [::MsgSend(msg)]; *)
       _ := send(ch_net, (msg, sig))
  	}
}

process bob(ch_net : udp_t) : client_t
{
  (* Use public key of Alice to verify message *)

  var pub_key_alice_path = "/keys/pub_alice"

  main 
  {
    
    var pub_key_alice_fd = fopen(pub_key_alice_path) in
    var pub_key_alice = fread(pub_key_alice_fd) in
    
    var msg_with_sig = recv(ch_net) in


    var m = fst(msg_with_sig) in
    var sig = snd(msg_with_sig) in 

    var res = verify(sig, m, pub_key_alice) in

    (* Close file after using key *)
    _ := fclose(pub_key_alice_fd)

    (* 
    case
    | [res = true] ->
        event [::IntegritySuccess(m)]
    | [res <> true] ->
        event [::IntegrityFail(m)]
    end;
    *)
    
    (* event [::BobClose ()] *)
  }
}


system
   alice(udp) with alice_fs
|| bob(udp) with bob_fs
requires  [
  (* System must eventually terminate *)
  lemma Reachable :
     exists-trace "Ex #i . AliceClose() @ #i";
    (* exists-trace "Ex #i #j . AliceClose() @ #i & BobClose() @ #j"; *)
  
  (* If msg has integrity, it should have been sent earlier *)
  lemma Correspondence :
    	all-traces "All msg #j  . IntegritySuccess(msg) @ #j ==> Ex #i . MsgSend (msg) @ i & i < j" 
  ]
