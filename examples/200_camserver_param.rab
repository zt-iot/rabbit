(** synchronous rpc channel *)
syscall connect_rpc (c) {
  put [c::req()];
  case 
  | [c::ack()] →
    new x = chid(c) in 
    put [c::conn()]; 
    x
  end
} 

syscall invoke_rpc (cid, arg1) {
  let c = cid.chid in
  put [c::invoke(arg1)]; 
  case [c:: Returned(v)] → v end
}

syscall accept_rpc (c){
  case [c::req()] → put [c::ack()] end
}


(* filesys *)
function h:1

(***********)
(** declare types with their classes *)
type readonly_t   : filesys

type client_t 	  : process
type client_ta_t  : process

type rpc_t 	  : channel

(***********)
(** access control *)

allow client_t rpc_t [connect_rpc, invoke_rpc]
allow client_ta_t rpc_t [accept_rpc]
allow client_ta_t rpc_t [.]
allow client_t rpc_t [.]

(***********)
(** installed channels and filesystems *)
channel rpc<> : rpc_t

(***********)
(** process templates *)
process client<k>(ch_rpc : rpc_t) : client_t 
{  
  main 
  {
    var conn = connect_rpc(ch_rpc) in 
    var sig = invoke_rpc(conn, 1) in
    event [::ClientClose ()]
  }
}

process client_ta<k>(ch_rpc : rpc_t) : client_ta_t 
{ 
  main 
  {
    _ := accept_rpc(ch_rpc);
    case
    | [ch_rpc::invoke(image)] →
          put[ch_rpc:: Returned(2)]
    end;
    event [::ClientTAClose ()]
  }
}


system 
  !n . (client<n>(rpc<n>) | client_ta<n>(rpc<n>)) 
requires  
[
  lemma ClientClose:
    reachable ::ClientClose() ;

  lemma ClientTAClose:
    reachable ::ClientTAClose()
]

