(**
send_good_weather: alice tries to send a message with "high" secrecy to bob

- once Bob receives the message, we establish that the message is 'secret' between alice and bob
- we verify with TAMARIN that they do not know the message, i.e., K(msg) is unreachable

If this program succeeds TAMARIN verification, it means that there are no secrecy violations
* )

type alice_t      : process
type bob_t        : process 


type udp_t : channel



syscall send(c, v) {
  put [c::store(v)]
}

syscall recv(c) {
  case 
  | [c::store(v)] â†’ v
  end
}



(* BEGIN TAMARIN access control *)
(* This section is only needed for TAMARIN access control *)
passive attack eaves_mem (v) {
  put [::Out(v)]
}

attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

allow alice_t [eaves_mem]
allow bob_t [eaves_mem]
(* END TAMARIN access control *)




allow alice_t udp_t [send, recv]
allow bob_t udp_t [send, recv]




(* The attacker is not able to do anything ; i.e. we give 0 permissions to the attacker_ty *)


process alice(ch_net : udp_t) : alice_t
{
  	main {
        new msg in (* alice_t creates a client_msg *)

        (* _ := eaves_mem(msg); *)
        _ := send(ch_net, msg);

        event [::AliceSend (msg) ]
  	}
}


process bob(ch_net : udp_t) : bob_t 
{
    main {
      var msg = recv(ch_net) in 

      (* _ := eaves_mem(msg); *)
      event [::SharedSecret (msg) ]

    }
}


channel udp : udp_t

system alice(udp) | bob(udp)
requires
[
    lemma MsgSecret : 
      all-traces "not(Ex msg #k #l . SharedSecret(msg) @ #k & K(msg) @ #l)" 
]