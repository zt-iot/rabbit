

(* security primitives *)
function vk : sigkey_client_ta -> ver_key_server



function senc : sigkey_client_ta -> symkey_client_ta -> cipher[sigkey_client_ta]


function sdec : cipher[sigkey_client_ta] -> symkey_client_ta -> sigkey_client_ta
equation sdec(senc(x, y), y) = x


function sign : client_img -> sigkey_client_ta -> client_ta_sig



function fst : 'a * 'b -> 'a
function snd : 'a * 'b -> 'b
equation fst ((x, y)) = x
equation snd ((x, y)) = y


function true : bool    (* A 0-argument function, aka a constant, which is of type bool *)

function verify : signature -> image -> ver_key_server -> bool

equation verify (sign(d, k), d, vk(k)) = true


(** asynchronous channels *)
syscall send(c : channel['a], v : 'a) : unit {
  put [c::store(v)]
}

syscall recv(c : channel['a]) : 'a {
  case 
  | [c::store(v)] →   v 
  end
}

(** synchronous rpc channel *)
syscall connect_rpc (c : channel['a]) : conn_client {
  put [c::req()];
  case 
  | [c::ack()] →
    new x = chid(c) in 
    put [c::conn()]; 
    x
  end
} 

syscall invoke_rpc (cid : conn_client, f : string, arg1 : 'a, arg2 : 'b) : 'c {
  let c : rpc_t = cid.chid in 
  put [c::invoke(f, arg1, arg2)]; 
  case [c:: Returned(v)] → v end
}

syscall close_rpc (cid : conn_client) : unit {
  let c = cid.chid in
  delete cid.chid;
  put[c::exit()]
}

syscall accept_rpc (c : channel['a]) : unit {
  case [c::req()] → put [c::ack()] end
}


syscall recv_verify_loop(ch_net : udp_t, pubkey : ver_key_server) : unit {
  repeat 
  | [] →
    var sig_img_pair : signature * image = recv(ch_net) in
    var res : bool = verify(fst(sig_img_pair), snd(sig_img_pair), pubkey) in 
    case 
    | [res =  true] →
      event [::ImgRecvValid(snd(sig_img_pair))]

    | [res != true] →  
      event [::ImgRecvInvalid(snd(sig_img_pair))]
    end
  until
  | [::False()] →  skip 
  end 	
}


