data bool
data string
data connection
data signature
data image
data filedescr

data list['a] (* if we want to declare a type with a polymorphic type parameter, we do it like this *)
              (* these "'a, 'b" etc. can be inferred whenever they are used *)

data keykind      (* we can think of keykind as a set with 5 elements: keykind := {Sym, Enc, Dec, Sig, Chk} *)
data key[keykind] (* declare a simple type which takes an element of another type as a parameter *)

data hash   (* assign this type to the result of a hash computation *)




(***********)
(** declare types with their classes *)
type readonly_t   : filesys  (* readonly_t is a specific kind of filesys *)

type server_t 	  : process
type client_t 	  : process
type client_ta_t  : process

type udp_t 	  : channel[image * signature] (* image and signature are exposed to attacker on udp_t channel *)
type rpc_t 	  : channel[client_img] (* the attacker cannot tamper or eavesdrop on the rpc_t channel *)

type conn_client : connection
type client_img : image

type symkey_client_ta : key[Sym] (* We have not specified the type of data which the key performs on *)
type sigkey_client_ta : key[Sig]
type client_ta_sig : signature

type ver_key_server : key[Chk]








type deckey_client : key[BadBadBad]   (* giving a declaration like this means we declare BadBadBad as a member of keykind *)



(* security primitives *)
function pk : key[Dec] -> key[Enc]
function vk : key[Sig] -> key[Chk]
function enc : 'a -> key[Sym] -> cipher['a]
function sign : 'a -> key[Sig] -> signature
function dec : cipher['a] -> key[Sym] -> 'a
function fst : 'a * 'b -> 'a
function snd : 'a * 'b -> 'b
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true : bool                                        (* A 0-argument function, aka a constant, which is of type bool *)
function verify : signature -> 'a -> key[Enc] -> bool
equation dec(enc(x, y), y) = x
equation verify (sign(d, k), d, vk(k)) = true




(* load syscalls on channels *)
load "udp_rpc_typed_opt_1.rab"

(* picture *)
syscall get_picture () : client_img {
  new v : client_img in 
  v
}

(* filesys *)
function h : 'a -> hash (* this function has to be built-in to Rabbit somehow *)
function hash_kdf : 'a -> keykind -> key[keykind] (* this function also has to be built-in to Rabbit somehow *)

syscall fopen (p : string) : filedescr['a] {
  (* p.File(x) indicates that x is stored in p. This is a Rabbit reserved fact *)
  (* It gets created when the filesys declarations get interpreted *)
  case [p.File(x)] ->
    new y = Fd(x) in (* TODO don't know how to type y in this case *)
    put [p.File(x)]; y
  end
}

syscall fread (y : filedescr['a]) : 'a {
  let x = y.Fd in
  x
}

syscall fclose (y : filedescr['a]) : unit {
  delete y.Fd
}





(***********)
(** access control necessary for TAMARIN translation *)
allow client_t udp_t [send]
allow server_t udp_t [recv]

allow client_t rpc_t [connect_rpc, invoke_rpc, close_rpc]
allow client_ta_t rpc_t [accept_rpc]
allow client_ta_t rpc_t [.]
allow client_t rpc_t [.]

allow client_t [get_picture]

allow client_ta_t readonly_t  [fopen, fread, fclose] 
allow server_t readonly_t     [fopen, fread, fclose]  



(** access control necessary for defining security lattice of TYPE SYSTEM *)
allow client_t client_img [get_picture, invoke_rpc, send]
allow client_t client_ta_sig [send, recv] (* client is allowed to receive a client_ta_sig type from `recv` and is allowed to pass it to `send` *)
allow client_t conn_client [connect_rpc, invoke_rpc, close_rpc] (* client is allowed to get a conn_client from `connect_rpc` and to give it to `invoke_rpc`, `close_rpc` *)

allow client_ta_t symkey_client_ta [.] (* client_ta is allowed to directly access symkey_client_ta *)
allow client_ta_t sigkey_client_ta [.] (* client_ta is allowed to directly interact with a term of `sigkey_client_ta` through equational theory functions *)

allow client_ta_t client_img [.] (* client_ta is allowed to directly interact with client_img type *)
allow client_ta_t client_ta_sig [send] (* client_ta is allowed to send client_ta_sig type *)
(* note that client_ta_t does not use functions `connect_rpc`, `invoke_rpc`, `close_rpc`, thus it is not necessary to give client_ta_t access to conn_client *)
(* allow client_ta_t conn_client [.] *)


allow server_t ver_key_server [.]


(***********)
(** attacker model *)

attack tampar_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

allow attack server_t [tampar_channel] 

(* we do not type v as we can choose explicitly to leak any value v to the attacker *)
passive attack eaves_mem (v) {
  put [::Out(v)]
}


allow client_t [eaves_mem]


(***********)
(** global constants *)
const fresh priv_k : sigkey_client_ta
const fresh sym_k : symkey_client_ta

(***********)
(** installed channels and filesystems *)
channel udp : udp_t

channel rpc : rpc_t

filesys server_fs = 
[ 
  {path: "/secret/pub", data: pk(priv_k), type: readonly_t} 
]

filesys client_ta_fs = 
[ 
  {path: "/secret/priv", data: enc(priv_k, sym_k), type: readonly_t}
]

(***********)
(** process templates *)
process client(ch_net : udp_t, ch_rpc : rpc_t) : client_t 
{  
  var privkey_path : string = "/secret/priv"
  var invoke_func : string = "sign_image"

  main 
  {

    var conn : conn_client = connect_rpc(ch_rpc) in 
    repeat 
    | [] ->
      var image : client_img = get_picture() in
      
      _ := eaves_mem(image);

      var sig : client_ta_sig = invoke_rpc(conn, invoke_func, image, privkey_path) in 
      
      _ := eaves_mem(sig);
      
      event [::ImgSend(image)];
      
      _ := send(ch_net, (sig, image))

    until 
    | [] -> skip
    end;

    _ := close_rpc(conn) ;

    event [::ClientClose ()]
  }
}

process client_ta(ch_rpc : rpc_t) : client_ta_t 
{
  var fek : symkey_client_ta = sym_k

  function sign_image(image : client_img, privkey_path : string) : client_ta_sig 
  {
    var privkey_fd : filedescr[cipher[sigkey_client_ta]] = fopen(privkey_path) in

    var privkey : cipher[sigkey_client_ta] = fread(privkey_fd) in (* what type should privkey get? The return type of `enc` *)

    var privkey0 : sigkey_client_ta = dec(privkey, fek) in 

    var sig : client_ta_sig = sign(image, privkey0) in

    _ := fclose(privkey_fd);

    sig 
  }

  main 
  {
    _ := accept_rpc(ch_rpc);
    
    repeat
    | [ch_rpc::invoke(fname, image, priv_path)] →
      case
      | [fname = "sign_image"] →
        var signed : client_ta_sig = sign_image(image, priv_path) in
        put[ch_rpc:: Returned(signed)]		

      | [fname <> "sign_image"] →
        event [InValidName(fname)]
      end 
    until
    | [ch_rpc::exit()] → skip 
    end;

    event [::ClientTAClose ()]
  }
}

process server(ch_net : udp_t) : server_t 
{
  var pubkey_path : string = "/secret/pub"

  main 
  {
    var pubkey_fd : filedescr[ver_key_server] = fopen(pubkey_path) in 
    var pubkey : ver_key_server = fread(pubkey_fd) in 
    repeat 
    | [] →
      var sig_img_pair : client_ta_sig * client_img = recv(ch_net) in
      var res : bool = verify(fst(p), snd(p), pubkey) in 
      case 
      | [res =  true] →
        event [::ImgRecvValid(snd(p))]

      | [res <> true] →  
        event [::ImgRecvInvalid(snd(p))]
      end
    until
    | [::False()] →  skip 
    end 	    
  }
}


(***********)
system 
  client(udp, rpc)
  ||	server(udp) with server_fs 
  ||	client_ta(rpc) with client_ta_fs
requires  [
  lemma Reachable :
  	exists-trace "Ex x #i #j #k  . ClientClose() @ #j & ClientTAClose() @ #k & ImgRecvValid(x) @ #i" ;
  lemma Correspondence :
  	all-traces "All x #j  . ImgRecvValid(x) @ #j ==> Ex #i . ImgSend (x) @ i & i < j" 
]

