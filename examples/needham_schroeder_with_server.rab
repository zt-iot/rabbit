(* security primitives *)
function pk:1
function enc:2
function dec:2
function fst:1
function snd:1
equation fst ((x, y)) = x
equation snd ((x, y)) = y
equation dec(enc(x, y), y) = x



(** Load some primitive system calls: *)
load "udp_rpc.rab"

(* System calls to interact with filesystems *)
function h:1

syscall fopen (path p) return h(p) 
  : [] -> [p.open()]

syscall fread (y) return x {y = h(p)}
  : [p.File(x), p.open()] -> [p.File(x), p.open()]

syscall fclose (y) {y = h(p)}
  : [p.open()] -> []




(***********)
(** Declare types with their respective classes *)
type readonly_t   : filesys

type client_t 	  : process
type server_t     : process

type udp_t 	  : channel






(***********)
(** Access control *)
allow client_t udp_t [send, recv]
allow server_t udp_t [send, recv]


(***********)
(** Attacker model *)

attack tamper_ch (channel c) : [c::store(v), In(atttacker_variable)] -> [c::store(atttacker_variable)]

(* Attacker can always attempt to decrypt a stored message on a channel with their private key *)
(* attack decrypt (channel c) : [c::store(v), In(attacker_priv_key)] -> [c::store(v), ::Out(dec(v, attacker_priv_key))] *)


passive attack eaves_mem (v) : [] -> [::Out(v)]

allow attack udp_t [tamper_ch, decrypt] (* I don't think the attack `decrypt` actually gets run like this tho... *)
allow client_t [eaves_mem]



(***********)
(** Global constants *)

const fresh nonce_alice
const fresh nonce_bob
const fresh priv_key_alice
const fresh priv_key_bob

(* Some public strings that identify Alice and Bob *)
const identity_alice = "Alice"
const identity_bob = "Bob"


(***********)
(** Installed channels and filesystems *)

channel udp_alice_server : udp_t

channel udp_bob_server : udp_t

filesys alice_fs = 
  [ 
    {path: "/keys/priv", data: priv_key_alice, type: readonly_t}
  ]

filesys bob_fs = 
  [
    {path: "/keys/priv", data: priv_key_bob, type: readonly_t}
  ]

filesys server_fs = 
  [
    {path: "/keys/alice_pub", data: pk(priv_key_alice), type: readonly_t},
    {path: "/keys/bob_pub", data: pk(priv_key_bob), type: readonly_t}
  ]




(** Process template for Alice *)
process alice(ch_net : udp_t) : client_t
{
    let nonce_ciphertext1 = nonce_alice;

    let pub_key_bob_path = "/keys/pub";
    let priv_key_alice_path = "/keys/priv";

  	main 
  	{
      skip @ DummyEvent1();
      skip @ DummyEvent2();

      (* Open file to retrieve private key of Alice *)
      let priv_key_alice_fd = fopen(priv_key_alice_path);
      let priv_key_alice = fread(priv_key_alice_fd);

      (* We have to ask for the public key of Bob *)
      let _ = send(ch_net, identity_bob);

      let pub_key_bob = recv(ch_net); (* This is actually a key of the attacker *)

      let ciphertext1 = enc((nonce_ciphertext1, identity_alice), pub_key_bob) @ UsedPublicKey(pub_key_bob);

      (* Send {nonce_A, A}_{K_{pb}} to Bob *)
			let _ = send(ch_net, ciphertext1);

      (* Receive {N_a, N_b}_{K_{PA}} from Bob *)
      let ciphertext2 = recv(ch_net);
      let plaintext2 = dec(ciphertext2, priv_key_alice);

      (* Get only the part of the message which is the nonce of Bob *)
      let nonce_bob = snd(plaintext2);

      (* Send back encrypted version of nonce_bob *)
      let ciphertext3 = enc(nonce_bob, pub_key_bob);

      let _ = send(ch_net, ciphertext3);


      fclose(priv_key_alice_fd);
  	}
}


process server(ch_net_alice : udp_t, ch_net_bob : udp_t) : server_t
{
  let pub_key_alice_path = "/keys/alice_pub";
  let pub_key_bob_path = "/keys/bob_pub";

  main 
  {
    let pub_key_alice_fd = fopen(pub_key_alice_path);
    let pub_key_alice = fread(pub_key_alice_fd);

    let pub_key_bob_fd = fopen(pub_key_bob_path);
    let pub_key_bob = fread(pub_key_bob_fd);

    (* Receive request from Alice for public key of Bob *)
    let alice_request = recv(ch_net_alice);

    (* Send back public key of Bob *)
    let _ = send(ch_net_alice, pub_key_bob) @ ServerPublicKeySent(pub_key_bob); (* This message will get tampered by the attacker *)

    (* forward message from attacker to B *)
    let forward1 = recv(ch_net_alice);
    let _ = send(ch_net_bob, forward1);

    (* Receive request from B to get identity of A *)
    let bob_request = recv(ch_net_bob);

    (* Send back public key of Alice *)
    let _ = send(ch_net_bob, pub_key_alice);

    (* Forward message from Bob to Alice *)
    let forward2 =  recv(ch_net_bob);
    let _ = send(ch_net_bob, forward2);
    
    (* Forward message from Alice to Bob *)
    let forward3 = recv(ch_net_alice);
    let _ = send(ch_net_alice, forward3);

    fclose(pub_key_alice_fd);
    fclose(pub_key_bob_fd);
  }
}


(** Process template for Bob *)
process bob(ch_net : udp_t) : client_t
{

  let nonce_bob_ciphertext2 = nonce_bob;
  let priv_key_bob_path = "/keys/priv";

  main
  {

    let priv_key_bob_fd = fopen(priv_key_bob_path);
    let priv_key_bob = fread(priv_key_bob_fd);
    
    let ciphertext1 = recv(ch_net);
    (* Decrypt message from Alice and get the first component of it, aka the nonce from Alice *)
    let plaintext1 = dec(ciphertext1, priv_key_bob);
    let nonce_alice_ciphertext2 = fst(plaintext1);

    (* We have to ask for the public key of Alice *)
    (* Server is only communication with the outside world *)
    let _ = send(ch_net, identity_alice);
    let pub_key_alice = recv(ch_net); (* this is really the public key of Alice *)

    (* Send back an encrypted version of nonce_alice and nonce_bob to Alice *)
    let ciphertext2 = enc((nonce_alice_ciphertext2, nonce_bob_ciphertext2), pub_key_alice);
    let _ = send(ch_net, ciphertext2);

    (* Receive back nonce_bob from Alice *)
    let ciphertext3 = recv(ch_net);
    let msg3 = dec(ciphertext3, priv_key_bob);

    (* Alice needs to prove that they can decrypt with their private key *)
    if (msg3 = nonce_bob)
    {
      (* Needham-Schroeder protocol success: only Alice and Bob should have access to the two nonces *)
      (* (Although of course this is not actually the case ) *)
      skip @ NHSuccess();
    }
    else 
    {
      (* Needham-Schroeder protocol failure *)
      skip @ NHFailure();
    }

    fclose(priv_key_bob_fd);
  }
}


(** System instantation *)
system
    alice(udp_alice_server) with alice_fs
||  bob(udp_bob_server) with bob_fs  
||  server(udp_alice_server, udp_bob_server) with server_fs
requires [
	lemma Reachability : reachable DummyEvent1() ; (* Don't care about reachability *)
  (* If Alice uses a certain public key to encrypt a message, that same public key should have been sent by the server *)
  lemma Correspondence : corresponds UsedPublicKey(key) ~> ServerPublicKeySent(key) 
  ]


