
data message 
data signature
data keykind      (* we can think of keykind as a set with 5 elements: keykind := {Sym, Enc, Dec, Sig, Chk} *)
data key[keykind] (* declare a simple type which takes an element of another type as a parameter *)


(***********)
(** declare types with their classes *)
type readonly_t   : filesys
type client_t 	  : process
type udp_t 	  : channel

type Sig : keykind
type Ver : keykind

type sign_key_alice : key[Sig]
type client_msg : message
type client_sig : signature


(* security primitives *)
function vk : key[Sig] -> key[Ver]
function sign : 'a -> key[Sig] -> signature
function fst : 'a * 'b -> 'a
function snd : 'a * 'b -> 'b
equation fst ((x, y)) = x
equation snd ((x, y)) = y
function true : bool
function verify : signature -> 'a -> key[Ver] -> bool
equation verify (sign(d, k), d, vk(k)) = true


(* load some primitive syscalls, incl. send and recv *)
load "udp_rpc.rab"

(* syscall that returns some fresh globally known message *)
syscall gen_message () {
  new v : client_msg in 
  v
}





(***********)
(** access control for TAMARIN translation *)

(* clients can both send and receive messages on udp_t channels *)
allow client_t udp_t [send, recv]

(** clients are allowed to generate fresh messages *)
allow client_t [gen_message]



(** access control necessary for defining security lattice of TYPE SYSTEM *)
allow alice_t client_msg [gen_message, send, recv]
allow alice_t client_sig [send]
allow alice_t client_sig [.]  (* able to create signatures using `sign` equational theory function *)
allow alice_t sign_key_alice [.] (* able to instantiate terms of sign_key_alice in memory instantiation *)

allow bob_t client_msg [gen_message, send, recv]
allow bob_t client_sig [send]
allow bob_t client_sig [.]  (* able to create signatures using `sign` equational theory function *)


allow attacker_ty client_msg [read, provide]
allow attacker_ty client_sig [read, provide]



(***********)
(** attacker model *)

(* declare active attacks *)

(* tamper message *)
attack tamper_channel on recv (c) {
  case [c::store(j), ::In(w)] ->
    w
  end
}

allow attack client_t [tamper_channel] 

passive attack eaves_mem (v) {
  put [::Out(v)]
}


allow client_t [eaves_mem]





(***********)
(** global constants *)
const fresh secret_key_alice

(***********)
(** installed channels and filesystems *)

channel udp : udp_t (* Only a single UDP channel for now *)


(***********)
(** process templates *)

process alice(ch_net : udp_t) : alice_t
{
    var priv_key_alice : sign_key_alice = secret_key_alice

  	main 
  	{
      var msg : client_msg = gen_message() in
      _ := eaves_mem(msg);

      var sig : client_sig = sign(msg, priv_key_alice) in
      _ := eaves_mem(sig);


      (* Send msg appended with signature to Bob *)
       event [::MsgSend(msg)];
      _ := send(ch_net, (msg, sig));

      event [::AliceClose ()]
  	}
}

process bob(ch_net : udp_t) : bob_t
{
  (* Use public key of Alice to verify message *)
  var pub_key_alice : key[Ver] = vk(priv_key_alice)

  main 
  {
    
    var msg_with_sig : message * signature = recv(ch_net) in

    var res : bool = verify(snd(msg_with_sig), fst(msg_with_sig), pub_key_alice) in

    case 
    | [res = true] ->
        event [::IntegritySuccess(fst(msg_with_sig))]
    | [res != true] ->
        event [::IntegrityFail(fst(msg_with_sig))]
    end;
    event [::BobClose ()]
  }
}


system
   alice(udp) | bob(udp)
requires  [
    lemma Reachable : 
      exists-trace "Ex #i #j . AliceClose () @ #i & BobClose() @ #j";
  
    lemma Correspondence :
    	all-traces "All msg #j  . IntegritySuccess(msg) @ #j ==> Ex #i . MsgSend (msg) @ i & i < j" 

  ]
