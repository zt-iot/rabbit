---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OUTPUT OF _build/default/src/rabbit.exe examples/digital_sig_filesys_inj_facts.rab --post-process --tag-transition -o tamarin_models/digital_sig_filesys_opt_no_eaves_sig.spthy && tamarin-prover tamarin_models/digital_sig_filesys_opt_no_eaves_sig.spthy --prove > tamarin_logs/digital_sig_filesys_opt_no_eaves_sig.log 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



theory rabbit begin

// Function signature and definition of the equational theory E

builtins: natural-numbers
functions: fst/1, pair/2, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    fst(<loc__1, loc__0>) = loc__1,
    fst(<x.1, x.2>) = x.1,
    snd(<loc__1, loc__0>) = loc__0,
    snd(<x.1, x.2>) = x.2,
    verify(sign(loc__1, loc__0), loc__1, pk(loc__0)) = true







rule (modulo E) Const__priv_key_alice:
   [ Fr( priv_key_alice ) ]
  --[
  Init__( 'rab__Const__priv_key_alice' ),
  Init__( <'rab__Const__priv_key_alice', priv_key_alice> )
  ]->
   [ !Const__( 'rab__priv_key_alice', priv_key_alice ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob__udp__recv:
   [ ] --> [ !ACP__( 'rab__Bob', 'rab__udp', 'rab__recv' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob__udp__send:
   [ ] --> [ !ACP__( 'rab__Bob', 'rab__udp', 'rab__send' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob____tamper_channel:
   [ ] --> [ !Attack__( 'rab__Bob', 'rab__tamper_channel' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice__udp__recv:
   [ ] --> [ !ACP__( 'rab__Alice', 'rab__udp', 'rab__recv' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice__udp__send:
   [ ] --> [ !ACP__( 'rab__Alice', 'rab__udp', 'rab__send' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice____tamper_channel:
   [ ] --> [ !Attack__( 'rab__Alice', 'rab__tamper_channel' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice__keys__priv:
   [ !Const__( 'rab__priv_key_alice', priv_key_alice ) ]
  --[ Init__( <'rab__Alice', 'rab____keys__priv'> ) ]->
   [ File__Alice( 'rab____keys__priv', priv_key_alice ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitAlice:
   [ ]
  --[ Init__( 'rab__Alice' ) ]->
   [ State__Alice( <'rab_____0', %1>, 'rab__', 'rab__', 'rab__', 'rab__' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice__merged_____0_____7__0_1__65:
   [
   State__Alice( <'rab_____0', %v__>, return__var__0, 'rab__', 'rab__',
                 'rab__'
   ),
   Fr( n__0__4 ), File__Alice( 'rab____keys__priv', n__0__10 ),
   !ACP__( 'rab__Alice', 'rab____keys__priv', 'rab__fopen' ),
   !ACP__( 'rab__Alice', 'rab____keys__priv', 'rab__fopen' ),
   !Eq__( n__0__10, n__0__19 ), Fr( n__0__11 )
   ]
  --[ Transition__Alice( 'rab__65', %v__ ), AliceClose( ) ]->
   [
   State__Alice( <'rab_____7__0_1', %v__>, 'rab__', n__0__19,
                 <n__0__11, 'rab__', n__0__11, n__0__4>, 'rab____keys__priv'
   ),
   File__Alice( 'rab____keys__priv', n__0__10 ),
   Fd__Alice( n__0__11, n__0__19 )
   ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice__merged_____7__0_1_____15__46:
   [
   State__Alice( <'rab_____7__0_1', %v__>, return__var__20, m__0__20,
                 <l__0__20, l__1__20, l__2__20, l__3__20>, t__0__20
   ),
   !ACP__( 'rab__Alice', 'rab__udp', 'rab__send' ),
   Fd__Alice( l__2__20, n__0__25 )
   ]
  --[ Transition__Alice( 'rab__46', %v__ ) ]->
   [
   State__Alice( <'rab_____15', %v__>, 'rab__', 'rab__', 'rab__', t__0__20
   ),
   Store( 'rab__udp', <l__3__20, sign(l__3__20, m__0__20)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob__keys__pub_alice:
   [ !Const__( 'rab__priv_key_alice', priv_key_alice ) ]
  --[ Init__( <'rab__Bob', 'rab____keys__pub_alice'> ) ]->
   [ File__Bob( 'rab____keys__pub_alice', pk(priv_key_alice) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) InitBob:
   [ ]
  --[ Init__( 'rab__Bob' ) ]->
   [ State__Bob( <'rab_____0', %1>, 'rab__', 'rab__', 'rab__', 'rab__' ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob__merged_____0_____6__0_0__91:
   [
   State__Bob( <'rab_____0', %v__>, return__var__0, 'rab__', 'rab__',
               'rab__'
   ),
   Fr( n__0__4 ), !Eq__( n__0__3, n__0__12 ),
   !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen' ),
   !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen' ),
   File__Bob( 'rab____keys__pub_alice', n__0__3 )
   ]
  --[ Transition__Bob( 'rab__91', %v__ ) ]->
   [
   State__Bob( <'rab_____6__0_0', %v__>, 'rab__', 'rab__',
               <'rab__udp', 'rab__', n__0__12, n__0__4>, 'rab____keys__pub_alice'
   ),
   File__Bob( 'rab____keys__pub_alice', n__0__3 ),
   Fd__Bob( n__0__4, n__0__12 )
   ]

  // loop breaker: [5]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob__merged_____0_____6__1_0__90:
   [
   State__Bob( <'rab_____0', %v__>, return__var__0, 'rab__', 'rab__',
               'rab__'
   ),
   Fr( n__0__4 ), !Eq__( n__0__3, n__0__12 ),
   !Attack__( 'rab__Bob', 'rab__tamper_channel' ),
   !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen' ),
   !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen' ),
   File__Bob( 'rab____keys__pub_alice', n__0__3 )
   ]
  --[ Transition__Bob( 'rab__90', %v__ ) ]->
   [
   State__Bob( <'rab_____6__1_0', %v__>, 'rab__', 'rab__',
               <'rab__udp', 'rab__', n__0__12, n__0__4>, 'rab____keys__pub_alice'
   ),
   File__Bob( 'rab____keys__pub_alice', n__0__3 ),
   Fd__Bob( n__0__4, n__0__12 )
   ]

  // loop breaker: [6]
  /* has exactly the trivial AC variant */

rule (modulo E) Bob__merged_____6__0_0_____17__57:
   [
   State__Bob( <'rab_____6__0_0', %v__>, return__var__18, 'rab__',
               <l__0__18, l__1__18, l__2__18, l__3__18>, t__0__18
   ),
   Store( l__0__18, n__0__18 ), !ACP__( 'rab__Bob', l__0__18, 'rab__recv' ),
   Fd__Bob( l__3__18, n__0__31 )
   ]
  --[ Transition__Bob( 'rab__57', %v__ ) ]->
   [ State__Bob( <'rab_____17', %v__>, 'rab__', 'rab__', 'rab__', t__0__18 )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Bob__merged_____6__1_0_____17__53:
   [
   State__Bob( <'rab_____6__1_0', %v__>, return__var__23, 'rab__',
               <l__0__23, l__1__23, l__2__23, l__3__23>, t__0__23
   ),
   Store( l__0__23, n__0__23 ), In( n__1__23 ),
   !ACP__( 'rab__Bob', l__0__23, 'rab__recv' ),
   Fd__Bob( l__3__23, n__0__31 )
   ]
  --[ Transition__Bob( 'rab__53', %v__ ) ]->
   [ State__Bob( <'rab_____17', %v__>, 'rab__', 'rab__', 'rab__', t__0__23 )
   ]

  /* has exactly the trivial AC variant */

restriction Init__:
  "∀ x #i #j. ((Init__( x ) @ #i) ∧ (Init__( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) Equality_gen:
   [ ] --> [ !Eq__( x, x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) NEquality_gen:
   [ ] --[ NEq___( x, y ) ]-> [ !NEq__( x, y ) ]

  /* has exactly the trivial AC variant */

restriction NEquality_rule:
  "∀ x #i. (NEq___( x, x ) @ #i) ⇒ (⊥)"
  // safety formula

lemma AlwaysStarts__ [reuse, use_induction]:
  all-traces
  "∀ x #i.
    (Loop__Back( x ) @ #i) ⇒ (∃ #j. (Loop__Start( x ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Loop__Back( x ) @ #i) ∧ ∀ #j. (Loop__Start( x ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (Loop__Start( x ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
    case case_1
    by solve( Loop__Back( x ) @ #i )
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma AlwaysStartsWhenEnds__ [reuse, use_induction]:
  all-traces
  "∀ x #i.
    (Loop__Finish( x ) @ #i) ⇒ (∃ #j. (Loop__Start( x ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Loop__Finish( x ) @ #i) ∧ ∀ #j. (Loop__Start( x ) @ #j) ⇒ ¬(#j < #i)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (Loop__Start( x ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
    case case_1
    by solve( Loop__Finish( x ) @ #i )
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma transition__Alice [reuse, use_induction]:
  all-traces
  "∀ x %i #j #k.
    ((Transition__Alice( x, %i ) @ #j) ∧ (Transition__Alice( x, %i ) @ #k)) ⇒
    (#j = #k)"
/*
guarded formula characterizing all counter-examples:
"∃ x %i #j #k.
  (Transition__Alice( x, %i ) @ #j) ∧ (Transition__Alice( x, %i ) @ #k)
 ∧
  ¬(#j = #k)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (#j < #k)  ∥ (#k < #j) )
    case case_1
    solve( Transition__Alice( x, %i ) @ #j )
      case Alice__merged_____0_____7__0_1__65
      solve( State__Alice( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                           'rab__'
             ) ▶₀ #j )
        case InitAlice
        by solve( !ACP__( 'rab__Alice', 'rab____keys__priv', 'rab__fopen'
                  ) ▶₃ #j )
      qed
    next
      case Alice__merged_____7__0_1_____15__46
      by solve( State__Alice( <'rab_____7__0_1', %i>, return__var__20,
                              m__0__20, <l__0__20, l__1__20, l__2__20, l__3__20>, t__0__20
                ) ▶₀ #j )
    qed
  next
    case case_2
    solve( Transition__Alice( x, %i ) @ #j )
      case Alice__merged_____0_____7__0_1__65
      solve( State__Alice( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                           'rab__'
             ) ▶₀ #j )
        case InitAlice
        by solve( !ACP__( 'rab__Alice', 'rab____keys__priv', 'rab__fopen'
                  ) ▶₃ #j )
      qed
    next
      case Alice__merged_____7__0_1_____15__46
      by solve( State__Alice( <'rab_____7__0_1', %i>, return__var__20,
                              m__0__20, <l__0__20, l__1__20, l__2__20, l__3__20>, t__0__20
                ) ▶₀ #j )
    qed
  qed
qed

lemma transition__Bob [reuse, use_induction]:
  all-traces
  "∀ x %i #j #k.
    ((Transition__Bob( x, %i ) @ #j) ∧ (Transition__Bob( x, %i ) @ #k)) ⇒
    (#j = #k)"
/*
guarded formula characterizing all counter-examples:
"∃ x %i #j #k.
  (Transition__Bob( x, %i ) @ #j) ∧ (Transition__Bob( x, %i ) @ #k)
 ∧
  ¬(#j = #k)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (#j < #k)  ∥ (#k < #j) )
    case case_1
    solve( Transition__Bob( x, %i ) @ #j )
      case Bob__merged_____0_____6__0_0__91
      solve( State__Bob( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                         'rab__'
             ) ▶₀ #j )
        case InitBob
        solve( !Eq__( n__0__3, n__0__12 ) ▶₂ #j )
          case Equality_gen
          by solve( !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen'
                    ) ▶₃ #j )
        qed
      qed
    next
      case Bob__merged_____0_____6__1_0__90
      solve( State__Bob( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                         'rab__'
             ) ▶₀ #j )
        case InitBob
        solve( !Eq__( n__0__3, n__0__12 ) ▶₂ #j )
          case Equality_gen
          solve( !Attack__( 'rab__Bob', 'rab__tamper_channel' ) ▶₃ #j )
            case Bob____tamper_channel
            by solve( !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen'
                      ) ▶₄ #j )
          qed
        qed
      qed
    next
      case Bob__merged_____6__0_0_____17__57
      by solve( State__Bob( <'rab_____6__0_0', %i>, return__var__18, 'rab__',
                            <l__0__18, l__1__18, l__2__18, l__3__18>, t__0__18
                ) ▶₀ #j )
    next
      case Bob__merged_____6__1_0_____17__53
      by solve( State__Bob( <'rab_____6__1_0', %i>, return__var__23, 'rab__',
                            <l__0__23, l__1__23, l__2__23, l__3__23>, t__0__23
                ) ▶₀ #j )
    qed
  next
    case case_2
    solve( Transition__Bob( x, %i ) @ #j )
      case Bob__merged_____0_____6__0_0__91
      solve( State__Bob( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                         'rab__'
             ) ▶₀ #j )
        case InitBob
        solve( !Eq__( n__0__3, n__0__12 ) ▶₂ #j )
          case Equality_gen
          by solve( !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen'
                    ) ▶₃ #j )
        qed
      qed
    next
      case Bob__merged_____0_____6__1_0__90
      solve( State__Bob( <'rab_____0', %i>, return__var__0, 'rab__', 'rab__',
                         'rab__'
             ) ▶₀ #j )
        case InitBob
        solve( !Eq__( n__0__3, n__0__12 ) ▶₂ #j )
          case Equality_gen
          solve( !Attack__( 'rab__Bob', 'rab__tamper_channel' ) ▶₃ #j )
            case Bob____tamper_channel
            by solve( !ACP__( 'rab__Bob', 'rab____keys__pub_alice', 'rab__fopen'
                      ) ▶₄ #j )
          qed
        qed
      qed
    next
      case Bob__merged_____6__0_0_____17__57
      by solve( State__Bob( <'rab_____6__0_0', %i>, return__var__18, 'rab__',
                            <l__0__18, l__1__18, l__2__18, l__3__18>, t__0__18
                ) ▶₀ #j )
    next
      case Bob__merged_____6__1_0_____17__53
      by solve( State__Bob( <'rab_____6__1_0', %i>, return__var__23, 'rab__',
                            <l__0__23, l__1__23, l__2__23, l__3__23>, t__0__23
                ) ▶₀ #j )
    qed
  qed
qed

lemma Correspondence:
  all-traces
  "∀ msg #j.
    (IntegritySuccess( msg ) @ #j) ⇒
    (∃ #i. (MsgSend( msg ) @ #i) ∧ (#i < #j))"
/*
guarded formula characterizing all counter-examples:
"∃ msg #j.
  (IntegritySuccess( msg ) @ #j)
 ∧
  ∀ #i. (MsgSend( msg ) @ #i) ⇒ ¬(#i < #j)"
*/
simplify
by solve( IntegritySuccess( msg ) @ #j )

lemma Reachable:
  exists-trace "∃ #i. AliceClose( ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i. (AliceClose( ) @ #i)"
*/
simplify
solve( State__Alice( <'rab_____0', %v__>, return__var__0, 'rab__',
                     'rab__', 'rab__'
       ) ▶₀ #i )
  case InitAlice
  by solve( !ACP__( 'rab__Alice', 'rab____keys__priv', 'rab__fopen'
            ) ▶₃ #i )
qed















/*
WARNING: the following wellformedness checks failed!

Unbound variables
=================

  rule `Equality_gen' has unbound variables: 
    x
  
  rule `NEquality_gen' has unbound variables: 
    x, y

Inexistant lemma actions
========================

  lemma `AlwaysStarts__' references action 
    fact "Loop__Back" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `AlwaysStarts__' references action 
    fact "Loop__Start" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `AlwaysStartsWhenEnds__' references action 
    fact "Loop__Finish" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `AlwaysStartsWhenEnds__' references action 
    fact "Loop__Start" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `Correspondence' references action 
    fact "IntegritySuccess" (arity 1, Linear) 
  but no rule has such an action.
  
  lemma `Correspondence' references action 
    fact "MsgSend" (arity 1, Linear) 
  but no rule has such an action.

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Equality_gen: 
Failed to derive Variable(s): x

Rule NEquality_gen: 
Failed to derive Variable(s): x, y
*/

/*
Generated from:
Tamarin version 1.10.0
Maude version 3.3
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2025-03-30 20:19:50.453495971 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: tamarin_models/digital_sig_filesys_opt_no_eaves_sig.spthy

  processing time: 2.45s
  
  WARNING: 9 wellformedness check failed!
           The analysis results might be wrong!
  
  AlwaysStarts__ (all-traces): verified (6 steps)
  AlwaysStartsWhenEnds__ (all-traces): verified (6 steps)
  transition__Alice (all-traces): verified (12 steps)
  transition__Bob (all-traces): verified (24 steps)
  Correspondence (all-traces): verified (2 steps)
  Reachable (exists-trace): falsified - no trace found (3 steps)

==============================================================================
